#!/usr/bin/env bash
###############################################################################
# mkexp                                                                       #
#-----------------------------------------------------------------------------# 
# Reads the `Experiment` file in the current working directory and creates    #
# jobfiles for the experiment.                                                #
###############################################################################
set -o pipefail
set -o errtrace
set -o nounset
set -o errexit

CUSTOM_CMAKE_FLAGS=""
# Find absolute path to this script
source=${BASH_SOURCE[0]}
while [ -L "$source" ]; do
  script_pwd=$(cd -P "$(dirname "$source")" >/dev/null 2>&1 && pwd)
  source=$(readlink "$source")
  [[ $source != /* ]] && source=$script_pwd/$source
done
script_pwd=$(cd -P "$(dirname "$source")" >/dev/null 2>&1 && pwd)
ROOT="$(realpath "$script_pwd/../")"

# Parse arguments
mode="generate"
skip_install=0

declare -A active_algorithms
while [[ $# -gt 0 ]]; do 
    case $1 in 
        --results)
            mode="results"
            shift
            ;;
        --plots)
            mode="plots"
            shift 
            ;;
        --clean)
            mode="clean"
            shift 
            ;;
        --purge)
            mode="purge"
            shift
            ;;
        --stats)
            mode="stats"
            shift
            ;;
        --help)
            mode="help"
            shift
            ;;
        --submit)
            mode="submit"
            shift
            ;;
        --install)
            mode="install"
            shift 
            ;;
        --install-fetched)
            mode="install-fetched"
            shift
            ;;
        --skip-install)
            skip_install=1
            shift
            ;;
        --fetch)
            mode="fetch"
            shift
            ;;
        --upload)
            mode="upload"
            shift
            ;;
        --download)
            mode="download"
            shift
            ;;
        --init)
            mode="init"
            shift 
            ;;
        --progress)
            mode="progress"
            shift 
            ;;
        -*|--*)
            echo "Error: unknown option $1"
            exit 1
            ;;
        *)
            active_algorithms[$1]=1
            shift
            ;;
    esac
done

if [[ $mode == "help" ]]; then 
    echo "Usage: call from within a directory containing a file named 'Experiment'"
    echo ""
    echo "The standard workflow is as follows:"
    echo "0. Add the bin/ directory to your PATH variable."
    echo "1. Create a new directory which will contain everything related to the experiment. In that directory, run \`mkexp --init\` to create the Experiment file."
    echo "2. Modify the Experiment file to configure your experiment. Once configured, run \`mkexp\` to build dependencies, partitioners and generate the jobfiles."
    echo "3. Run \`./submit.sh\` to execute the experiment. This will usually happen in the background."
    echo "4. Once the experiment has finished, parse the log files by running \`mkexp --results\`. On a system with R installed, you can generate some standard plots by running \`mkexp --plots\` afterwards."
    echo ""
    echo "mkexp [--init, --submit, --fetch, --install-fetched, --skip-install, --results, --plot, --clean, --purge, --stats, --upload, --download, --help] [algorithms...]"
    echo ""
    echo "Without any options, generate the jobfiles and directory structure to run the experiment."
    echo "If not all algorithms should be included in the job files, specify a subset of defined algorithms as positional arguments"
    echo ""
    echo "Options are:"
    echo "    --init: Initialize a new experiment"
    echo "    --submit: Start the experiment"
    echo "    --fetch: Download libraries and partitioners, but do not build them yet"
    echo "    --install-fetched: Build and install libraries and partitioners that were already fetched, i.e., run this after running --fetched"
    echo "    --skip-install: Regenerate jobfiles, but do not recompile the partitioners"
    echo "    --results: Parse log files and output CSV files"
    echo "    --plot:  Generate performance- and running time plots from the CSV files"
    echo "    --clean: Delete generated experiment files"
    echo "    --purge: --clean, but also delete log and result files"
    echo "    --stats: Compute some statistics from the CSV files"
    echo "    --upload: Upload the experiments to a remote machine"
    echo "    --download: Download results from a remove machine"
    echo "    --help: Print this help message"
    echo ""
    echo "This framework supports running experiments on a machine without internet access."
    echo "To do so, configure the experiment on a machine with internet access, then run \`mkexp --fetch\`."
    echo "Afterwards, upload everything to the remote machine using \`mkexp --upload\`, and compile it there by running \`mkexp --install-fetched\`."
    echo "Once the experiments has finished, download the log files using \`mkexp --download\` and proceed as normal."
    exit 0
fi
if [[ $mode == "init" ]]; then 
    cp "$ROOT/example/Experiment" "$PWD"
    exit 0
fi

# If positional arguments are present, use it to filter active algorithms
filter_algorithms=0
if [[ -v active_algorithms[@] ]]; then
    filter_algorithms=1
fi

###############################################################################

LoadAlgorithm() {
    local name="$1"
    local filename="$script_pwd/../partitioners/$name"
    [[ -f "$filename" ]] || {
        echo "Error: invalid partitioner $name"
        echo "       $filename"
        exit 1
    }
    . "$filename"
}

LoadLibrary() {
    local name="$1"
    local filename="$script_pwd/../libs/$name"
    [[ -f "$filename" ]] || {
        echo "Error: invalid library $name"
        echo "       $filename"
        exit 1
    }
    . "$filename"
}

InvokePartitionerFromDisk() {
    local -n invoke_partitioner_from_disk_args=$1
    LoadAlgorithm "${invoke_partitioner_from_disk_args[algorithm_base]}"
    InvokeFromDisk invoke_partitioner_from_disk_args
}

InvokePartitionerFromKaGen() {
    local -n invoke_partitioner_from_kagen_args=$1
    LoadAlgorithm "${invoke_partitioner_from_kagen_args[algorithm_base]}"
    InvokeFromKaGen invoke_partitioner_from_kagen_args
}

FetchPartitioner() {
    local -n fetch_partitioner_args=$1
    LoadAlgorithm "${fetch_partitioner_args[algorithm_base]}"
    Fetch fetch_partitioner_args
}

FetchLibrary() {
    local -n fetch_library_args=$1
    LoadLibrary "${fetch_library_args[library]}"
    Fetch fetch_partitioner_args
}

InstallPartitioner() {
    local -n install_partitioner_args=$1
    LoadAlgorithm "${install_partitioner_args[algorithm_base]}"
    Install install_partitioner_args
}

InstallLibrary() {
    local -n install_library_args=$1
    LoadLibrary "${install_library_args[library]}"
    Install install_partitioner_args
}

LoadSystem() {
    name="$1"
    filename="$script_pwd/../systems/$name"
    [[ -f "$filename" ]] || {
        echo "Error: invalid system $name"
        echo "       $filename"
        exit 1
    }
    . "$filename"
}

# Parse argument to "Threads"
ParseNodes() {
    if [[ "$1" == *x*x* ]]; then
        echo "${1%%x*}"
    else
        echo "1"
    fi
}

ParseMPIs() {
    if [[ "$1" == *x* ]]; then 
        without_threads="${1%x*}"
        echo "${without_threads#*x}"
    else # Number of nodes can be omitted
        echo "1"
    fi
}

ParseThreads() {
    echo "${1##*x}"
}

ParseTimelimit() {
    time="$1"
    seconds="${time##*:}"
    minutes=0
    hours=0
    days=0
    if [[ "$time" == *:* ]]; then 
        time="${time%:*}"
        minutes="${time##*:}"
    fi 
    if [[ "$time" == *:* ]]; then
        time="${time%:*}"
        hours="${time##*:}"
    fi
    if [[ "$time" == *:* ]]; then
        time="${time%:*}"
        days="${time}"
    fi
    
    echo $((seconds+60*minutes+60*60*hours+24*60*60*days))
}

ParseKaGenArgument() {
    param_argument_name="$1"
    param_arguments="${@:2}"
    for kv in ${param_arguments[@]}; do 
        key=${kv%=*}
        value=${kv#*=}
        if [[ "$key" == "$param_argument_name" ]]; then 
            echo "$value"
            return 0
        fi
    done
}

###############################################################################

# Functions to be called from the Experiment file
declare -A _algorithm_definition_names=()
declare -A _algorithm_definition_bases=()
declare -A _algorithm_definition_arguments=()
declare -A _algorithm_definition_versions=()
declare -A _algorithm_build_options=()
declare -a _libs=()
declare -a _algorithms=()
declare -a _ks=()
declare -a _seeds=()
declare -a _graphs=()
declare -a _epsilons=()
declare -a _nodes_x_mpis_x_threads=()
declare -a _kagen_graphs=()

_timelimit=""
_timelimit_per_instance=""
_system="generic"
_mpi="none"
_oversubscribe_mpi=0
_scale_ks=0
_username=""
_project=""
_partition=""

ResetExperiment() {
    _algorithms=()
    _libs=()
    _ks=()
    _seeds=()
    _graphs=()
    _epsilons=()
    _nodes_x_mpis_x_threads=()
    _kagen_graphs=()
    _timelimit=""
    _time_per_instance=""
    _system="generic"
    _mpi="none"
    _oversubscribe_mpi=0
    _scale_ks=0
}

BuildOptions() {
    name="$1"
    options="${*:2}"
    _algorithm_build_options[$name]="$options"
}

Oversubscribe() {
    _oversubscribe_mpi=1
}

UseLibrary() {
    _libs+=(${@})
}

DefineAlgorithm() {
    name="$1"
    base_algorithm="$2"
    custom_arguments="${*:3}"

    if [[ "$name" == "$base_algorithm" ]]; then 
        echo "Error: algorithm $name cannot be based on itself"
        exit 1
    fi

    [[ ! -v "_algorithm_definition_names[$name]" ]] || {
        echo "Warning: overwriting already defined algorithm $name"
    }

    _algorithm_definition_names[$name]=1
    _algorithm_definition_bases[$name]="$base_algorithm"
    _algorithm_definition_arguments[$name]="$custom_arguments"
}

DefineAlgorithmVersion() {
    name="$1"
    base_algorithm="$2"
    version="$3"

    if [[ "$name" == "$base_algorithm" ]]; then 
        echo "Error: algorithm $name cannot be based on itself"
        exit 1
    fi

    [[ ! -v "_algorithm_definition_names[$name]" ]] || {
        echo "Warning: overwriting already defined algorithm $name"
    }

    [[ "$(GetAlgorithmVersion "$base_algorithm")" == "latest" ]] || {
        echo "Warning: base algorithm $base_algorithm of version definition $name is already a version definition with version $(GetAlgorithmVersion "$base_algorithm")"
    }

    _algorithm_definition_names[$name]=1
    _algorithm_definition_bases[$name]="$base_algorithm"
    _algorithm_definition_arguments[$name]=""
    _algorithm_definition_versions[$name]="$version"
}

System() {
    _system="$1"
}

Username() {
    _username="$1"
}

Project() {
    _project="$1"
}

Partition() {
    _partition="$1"
}

MPI() {
    _mpi="$1"
}

Algorithms() {
    _algorithms+=(${@})
}

Threads() {
    _nodes_x_mpis_x_threads+=(${@})
}

Seeds() {
    _seeds+=(${@})
}

Ks() {
    _ks+=(${@})
}

ScaleKs() {
    _scale_ks=1
}

Timelimit() {
    _timelimit="$1"
}

TimelimitPerInstance() {
    _timelimit_per_instance="$1"
}

Graphs() {
    for filename in ${1%/}/*.*; do 
        _graphs+=("${filename%.*}")
    done
}

Graph() {
    _graphs+=("${1%.*}")
}

Epsilons() {
    _epsilons+=(${@})
}

KaGen() {
    generator="$1"
    arguments="${@:2}"
    _kagen_graphs+=("$generator $arguments")
}

GetAlgorithmBase() {
    algorithm="$1"
    if [[ -v "_algorithm_definition_names[$algorithm]" ]]; then 
        GetAlgorithmBase "${_algorithm_definition_bases[$algorithm]}"
    else 
        echo "$algorithm"
    fi
}

GetAlgorithmArguments() {
    algorithm="$1"
    if [[ -v "_algorithm_definition_names[$algorithm]" ]]; then 
        additional_arguments=$(GetAlgorithmArguments "${_algorithm_definition_bases[$algorithm]}")
        echo "${_algorithm_definition_arguments[$algorithm]} $additional_arguments"
    else 
        echo ""
    fi
}

GetAlgorithmVersion() {
    algorithm="$1"
    if [[ -v "_algorithm_definition_names[$algorithm]" ]]; then 
       if [[ -v "_algorithm_definition_versions[$algorithm]" ]]; then 
           echo "${_algorithm_definition_versions[$algorithm]}"
       else 
           GetAlgorithmVersion "${_algorithm_definition_bases[$algorithm]}"
       fi
    else 
        echo "latest"
    fi
}

PrintSummary() {
    if [[ $mode != "generate" ]]; then 
        return 0
    fi

    echo "Custom algorithm definitions:"
    for algorithm in ${!_algorithm_definition_names[@]}; do 
        echo "- $algorithm <- $(GetAlgorithmBase "$algorithm")"
        echo "  Version: $(GetAlgorithmVersion "$algorithm")"
        echo "  Arguments: $(GetAlgorithmArguments "$algorithm")"
    done
    echo ""

    echo "Algorithms:"
    for algorithm in ${_algorithms[@]}; do 
        echo "- $algorithm"
    done
    echo ""

    echo "Graphs:"
    for graph in ${_graphs[@]}; do 
        echo "- $graph"
    done
    echo ""

    echo "KaGen graphs:"
    for i in "${!_kagen_graphs[@]}"; do 
        arguments="${_kagen_graphs[$i]}"
        echo "- $arguments"
    done 
    echo ""

    echo "Parallel executions:"
    for nodes_x_mpis_x_threads in ${_nodes_x_mpis_x_threads[@]}; do
        echo "- $(ParseNodes "$nodes_x_mpis_x_threads") nodes X $(ParseMPIs "$nodes_x_mpis_x_threads") MPI processes X $(ParseThreads "$nodes_x_mpis_x_threads") threads"
    done
    echo ""

    echo "Seeds: ${_seeds[*]}"
    echo "Ks: ${_ks[*]}"
}

# Check that there is an Experiment file
[[ -f "Experiment" ]] || {
    echo "Error: no Experiment file contained in the current working directory"
    echo "  Run 'mkexp --init' to initialize a new experiment in the current directory"
    exit 1
}

# Read Experiment file
. Experiment

# Filter active algorithms
if [[ $filter_algorithms != "0" ]]; then 
    declare -a filtered_algorithms
    for algorithm in ${_algorithms[@]}; do 
        if [[ -v "active_algorithms[$algorithm]" ]]; then 
            filtered_algorithms+=("$algorithm")
        else 
            echo "Disable target $algorithm"
        fi
    done
    _algorithms=("${filtered_algorithms[@]}")
fi

# Install required partitioners
PREFIX="$PWD/usr"
mkdir -p "$PREFIX" "$PREFIX/bin" "$PREFIX/lib" "$PREFIX/include"

export PATH="$PREFIX/bin:$PATH"
export C_INCLUDE_PATH="$PREFIX/include:${C_INCLUDE_PATH-""}"
export CPLUS_INCLUDE_PATH="$PREFIX/include:${CPLUS_INCLUDE_PATH-""}"
export LIBRARY_PATH="$PREFIX/lib:${LIBRARY_PATH-""}"
export LD_LIBRARY_PATH="$PREFIX/lib:${LD_LIBRARY_PATH-""}"
export CMAKE_PREFIX_PATH="$PREFIX/:${CMAKE_PREFIX_PATH-""}"

ExportEnv() {
    echo "export PATH=\"$PATH\""
    echo "export C_INCLUDE_PATH=\"$C_INCLUDE_PATH\""
    echo "export CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH\""
    echo "export LIBRARY_PATH=\"$LIBRARY_PATH\""
    echo "export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\""
}

GenerateBinaryName() {
    local -n args=$1
    echo "$PREFIX/bin/${args[algorithm_base]}-${args[algorithm_version]}"
}

GenerateKaGenBinaryName() {
    local -n args=$1
    echo "$PREFIX/bin/KaGen_${args[algorithm_base]}"
}

LoadSystem "$_system"
if [[ $mode == "install" || $mode == "install-fetched" ]]; then 
    SetupBuildEnv
fi

if [[ $skip_install == "0" && ($mode == "generate" || $mode == "fetch" || $mode == "install" || $mode == "install-fetched" ) ]]; then
    for lib in ${_libs[@]}; do 
        declare -A library 
        library[library]="$lib"
        #library[build_options]=""
        #if [[ -v "_algorithm_build_options[${partitioner[algorithm_base]}]" ]]; then 
        #    partitioner[build_options]="${_algorithm_build_options[${partitioner[algorithm_base]}]}"
        #fi
        if [[ $mode == "fetch" ]]; then 
            FetchLibrary library
        elif [[ $mode == "install-fetched" ]]; then 
            InstallLibrary library
        else
            FetchLibrary library
            InstallLibrary library
        fi
    done
    for algorithm in ${_algorithms[@]}; do
        declare -A partitioner
        partitioner[algorithm]="$algorithm"
        partitioner[algorithm_base]=$(GetAlgorithmBase "$algorithm")
        partitioner[algorithm_version]=$(GetAlgorithmVersion "$algorithm")
        partitioner[binary_disk]="$(GenerateBinaryName partitioner)"
        partitioner[binary_kagen]="$(GenerateKaGenBinaryName partitioner)"
        partitioner[install_disk]=$((${#_graphs[@]}))
        partitioner[install_kagen]=$((${#_kagen_graphs[@]}))
        partitioner[build_options]=""
        if [[ -v "_algorithm_build_options[${partitioner[algorithm_base]}]" ]]; then 
            partitioner[build_options]="${_algorithm_build_options[${partitioner[algorithm_base]}]}"
        fi
        if [[ $mode == "fetch" ]]; then 
            FetchPartitioner partitioner
        elif [[ $mode == "install-fetched" ]]; then 
            InstallPartitioner partitioner
        else
            FetchPartitioner partitioner
            InstallPartitioner partitioner
        fi
    done
fi

# Default unset variables
[[ -v "_nodes_x_mpis_x_threads" ]] || _nodes_x_mpis_x_threads+=("1x1x1")
[[ -v "_epsilons" ]] || _epsilons+=("0.03")
[[ -v "_seeds" ]] || _seeds+=("0")
gitignore_filename="$PWD/.gitignore"
submit_filename="$PWD/submit.sh"
job_files_dir="$PWD/jobs"
log_files_dir="$PWD/logs"
misc_files_dir="$PWD/misc"
results_dir="$PWD/results"

# Create files file
if [[ $mode == "generate" ]]; then 
    cat <<EOT > "$gitignore_filename"
submit.sh
parse.sh
nohup.out
logs/
jobs/
usr/
.Rhistory
slurm/
slurm-*
logs*/
all_jobs.sh
misc/
EOT

    echo "#!/usr/bin/env bash" > "$submit_filename"
    chmod +x "$submit_filename"

    mkdir -p "$job_files_dir"
    mkdir -p "$log_files_dir"
    mkdir -p "$misc_files_dir"

    for algorithm in ${_algorithms[@]}; do 
        mkdir -p "$log_files_dir/$algorithm"
        mkdir -p "$misc_files_dir/$algorithm"
    done
fi

if [[ $mode == "parse" ]]; then
    mkdir -p "$results_dir"
fi

# Generate jobs
LoadSystem "$_system"

GenerateJobfileName() {
    local -n args=$1
    echo "jobs_${args[num_nodes]}x${args[num_mpis]}x${args[num_threads]}.sh"
}

GenerateInvocIdentifier() {
    local -n args=$1
    echo "$(basename "${args[graph]}")___P${args[num_nodes]}x${args[num_mpis]}x${args[num_threads]}_seed${args[seed]}_eps${args[epsilon]}_k${args[k]}"
}

GenerateKaGenIdentifier() {
    local -n args=$1
    echo "${args[kagen_stringified]}___P${args[num_nodes]}x${args[num_mpis]}x${args[num_threads]}_seed${args[seed]}_eps${args[epsilon]}_k${args[k]}"
}

ScaleKaGenGraph() {
    local -n args=$1
    local kagen="$2"

    num_nodes=${args[num_nodes]}
    num_mpis=${args[num_mpis]}
    num_threads=${args[num_threads]}
    num_pes=$((num_nodes*num_mpis*num_threads))
    log_nodes=$(printf "%.0f" $(echo "l($num_nodes)/l(2)" | bc -l))
    log_mpis=$(printf "%.0f" $(echo "l($num_mpis)/l(2)" | bc -l))
    log_threads=$(printf "%.0f" $(echo "l($num_threads)/l(2)" | bc -l))
    log_pes=$(printf "%.0f" $(echo "l($num_pes)/l(2)" | bc -l))

    sub=$(echo "$kagen" | N=$num_nodes M=$num_mpis T=$num_threads P=$num_pes lN=$log_nodes lM=$log_mpis lT=$log_threads lP=$log_pes envsubst)
    eval "echo $sub"
}

if [[ $mode == "generate" ]]; then
    infofile="INFO"
    echo "Generated at $(date) on $(hostname)" > "$infofile"

    declare -a jobfiles
    declare -A invoc=( [mpi]=$_mpi [timelimit]=$_timelimit )
    invoc[misc_dir]="$misc_files_dir"

    for nodes_x_mpis_x_threads in ${_nodes_x_mpis_x_threads[@]}; do
        invoc[num_nodes]=$(ParseNodes "$nodes_x_mpis_x_threads")
        invoc[num_mpis]=$(ParseMPIs "$nodes_x_mpis_x_threads")
        invoc[num_threads]=$(ParseThreads "$nodes_x_mpis_x_threads")
        invoc[job]="$job_files_dir/$(GenerateJobfileName invoc)"

        GenerateJobfileHeader invoc > "${invoc[job]}"
        ExportEnv >> "${invoc[job]}"
        jobfiles+=("${invoc[job]}")

        for seed in ${_seeds[@]}; do
            invoc[seed]=$seed

            for epsilon in ${_epsilons[@]}; do 
                invoc[epsilon]=$epsilon

                for algorithm in ${_algorithms[@]}; do
                    invoc[algorithm]=$algorithm
                    invoc[algorithm_base]=$(GetAlgorithmBase "$algorithm")
                    invoc[algorithm_version]=$(GetAlgorithmVersion "$algorithm")
                    invoc[algorithm_arguments]=$(GetAlgorithmArguments "$algorithm")
                    invoc[binary_disk]="$(GenerateBinaryName invoc)"
                    invoc[binary_kagen]="$(GenerateKaGenBinaryName invoc)"

                    for k in ${_ks[@]}; do
                        if [[ "$_scale_ks" == "1" ]]; then 
                            k=$((k*nodes)) 
                        fi
                        invoc[k]=$k

                        # Graphs from disk
                        invoc[binary]="${invoc[binary_disk]}"
                        for graph in ${_graphs[@]}; do
                            invoc[graph]="$graph"
                            invoc[id]="$(GenerateInvocIdentifier invoc)"
                            invoc[log]="$log_files_dir/${invoc[algorithm]}/${invoc[id]}.log"
                            invoc[exe]="$(InvokePartitionerFromDisk invoc)"
                            invoc[exe]="$(GenerateJobfileEntry invoc)"
                            if [[ "$_timelimit_per_instance" != "" ]]; then 
                                invoc[exe]="timeout -v $(ParseTimelimit "$_timelimit_per_instance")s ${invoc[exe]}"
                            fi
                            echo "${invoc[exe]} >> ${invoc[log]} 2>&1" >> "${invoc[job]}"
                        done 

                        # KaGen graphs
                        invoc[binary]="${invoc[binary_kagen]}"
                        for i in ${!_kagen_graphs[@]}; do
                            kagen="$(ScaleKaGenGraph invoc "${_kagen_graphs[$i]}")"
                            kagen_arguments_arr=($kagen)
                            invoc[kagen_stringified]="$(echo "$kagen" | sed -E 's/filename=([^\/]*\/)*(.*)\.kargb/filename=\2/' | tr ' ' '-')"
                            invoc[kagen_arguments_stringified]="$(echo "$kagen" | tr ' ' ';')"
                            invoc[kagen_generator]="${kagen_arguments_arr[0]}"
                            invoc[kagen_arguments]="${kagen_arguments_arr[@]:1}"
                            invoc[id]="$(GenerateKaGenIdentifier invoc)"
                            invoc[log]="$log_files_dir/${invoc[algorithm]}/${invoc[id]}.log"
                            invoc[exe]="$(InvokePartitionerFromKaGen invoc)"
                            invoc[exe]="$(GenerateJobfileEntry invoc)"
                            if [[ "$_timelimit_per_instance" != "" ]]; then 
                                invoc[exe]="timeout -v $(ParseTimelimit "$_timelimit_per_instance")s ${invoc[exe]}"
                            fi

                            echo "${invoc[exe]} >> ${invoc[log]} 2>&1" >> "${invoc[job]}"
                        done # generator
                    done # k
                done # algorithm
            done # epsilon
        done # parallelism setting
    done

    GenerateJobfileSubmission ${jobfiles[@]} >> $submit_filename
fi 

if [[ $mode == "results" ]]; then
    mkdir -p "$results_dir"
    for algorithm in ${_algorithms[@]}; do 
        base=$(GetAlgorithmBase "$algorithm")
        mkresults "$base" "$log_files_dir/$algorithm" > "$results_dir/$algorithm.csv"
    done
fi

if [[ $mode == "clean" || $mode == "purge" ]]; then 
    rm -rf "$submit_filename" "$job_files_dir" parse.sh
fi
if [[ $mode == "purge" ]]; then
    echo "!!! About to delete the following files and directories:"
    echo "    $log_files_dir"
    echo "    $results_dir"
    echo "    $PREFIX"
    echo "    $PWD/INFO"
    read -p "Continue (y/n)?" cont
    if [[ $cont == "y" ]]; then
        rm -rf "$log_files_dir" "$results_dir" "$PREFIX" "$PWD/INFO"
    fi
fi

if [[ $mode == "plots" ]]; then 
    mkplots ${_algorithms[@]}
fi

if [[ $mode == "stats" ]]; then 
    mkstats ${_algorithms[@]}
fi

if [[ $mode == "submit" ]]; then 
    if [[ ! -f "$submit_filename" ]]; then 
        mkexp
    fi
    bash "$submit_filename"
fi

if [[ $mode == "upload" ]]; then 
    UploadExperiment    
fi
if [[ $mode == "download" ]]; then
    DownloadExperiment
fi

if [[ $mode == "progress" ]]; then
    num_total_logs=$(( \
        ${#_nodes_x_mpis_x_threads[@]} * \
        ${#_seeds[@]} * \
        ${#_epsilons[@]} * \
        ${#_ks[@]} * \
        (${#_graphs[@]} + ${#_kagen_graphs[@]}) \
    ))
    num_total_logs_per_seed=$((num_total_logs / ${#_seeds[@]}))

    max_len=$(tput cols)
    name_max_len=20

    name_len=0
    for algorithm in ${_algorithms[@]}; do
        if (( ${#algorithm} > $name_len )); then 
            name_len=${#algorithm}
        fi
    done
    if (( name_len > name_max_len )); then 
        name_len=$name_max_len
    fi

    progress_len=$((max_len - name_len - 18))

    OutputProgressLine() {
        local dir="$1"
        local name="$2"
        local filter="$3"
        local n="$4"

        cur=$(ls -1 "$dir" | grep "$filter" | wc -l)
        filled=$((cur * progress_len / n))
        if (( ${#name} > $name_max_len - 4 )); then 
            printf "%.$((name_len-3))s... " "$name"
        else 
            printf "%-${name_len}s " "$name"
        fi
        printf "[%-${progress_len}s]" $(printf "%${filled}s" | tr ' ' '#')
        if (( cur == 0 )); then
            printf " INACTIVE 00:00"
        else 
            oldest_file=$(find "$dir" -name "*$filter*" -type f -printf '%T+ %p\n' | sort | head -n 1 | cut -d ' ' -f 2)
            newest_file=$(find "$dir" -name "*$filter*" -type f -printf '%T+ %p\n' | sort | tail -n 1 | cut -d ' ' -f 2)
            oldest_file_time=$(date -r "$oldest_file" +%s)
            newest_file_time=$(date -r "$newest_file" +%s)
            time_diff=$((newest_file_time - oldest_file_time))
            hours=$((time_diff / 3600))
            minutes=$(( (time_diff % 3600) / 60 ))
            if (( cur == n )); then 
                printf " DONE     "
            else 
                printf " ACTIVE   "
            fi
            printf "%02d:%02d" $hours $minutes
        fi
        printf "\n"
    }

    for algorithm in ${_algorithms[@]}; do
        dir="$log_files_dir/$algorithm"

        OutputProgressLine "$dir" "$algorithm" "" "$num_total_logs"
        if (( ${#_seeds[@]} > 1 )); then 
            for seed in ${_seeds[@]}; do
                prefix=" |- "
                if (( seed == ${_seeds[-1]} )); then 
                    prefix=" \`- "
                fi
                OutputProgressLine "$dir" "${prefix}Seed $seed" "seed$seed" "$num_total_logs_per_seed"
            done
        fi
    done
fi

exit 0

